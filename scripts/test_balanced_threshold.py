#!/usr/bin/env python3
"""
Test script to find the optimal threshold for mathematical detection.
"""

import re
from typing import Dict, List, Tuple


class ConfigurableMathDetector:
    """Math detector with configurable threshold."""
    
    def __init__(self, threshold=5):
        self.math_detection_threshold = threshold
        self.min_math_length = 3
        self._compile_patterns()
    
    def _compile_patterns(self):
        self.math_symbols_pattern = re.compile(
            r'[∫∑∏∂∇∞≤≥≠≈±∓×÷∘√αβγδεζηθλμπρστφχψωΓΔΘΛΠΣΦΨΩ]'
        )
        
        self.equation_patterns = [
            re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*[a-zA-Z0-9_+\-*/()^√∫∑∏∂∇∞≤≥≠≈±∓×÷∘αβγδεζηθλμπρστφχψωΓΔΘΛΠΣΦΨΩ\s]+'),
            re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*\s*[+\-*/^]\s*[a-zA-Z0-9_]+'),
            re.compile(r'[a-zA-Z0-9_+\-*/()^]+/[a-zA-Z0-9_+\-*/()^]+'),
        ]
        
        self.rejection_patterns = [
            re.compile(r'^\s*\d+\s*$'),
            re.compile(r'^\s*\[\s*\d+\s*\]\s*$'),
            re.compile(r'^\s*[a-zA-Z]\d*\s*$'),
            re.compile(r'^\s*\d+\.\s*[A-Z][a-zA-Z\s]+$'),
            re.compile(r'\b(page|section|chapter|figure|table|equation|example)\s+\d+\b', re.IGNORECASE),
            re.compile(r'^[A-Z]{2,5}$'),
        ]
        
        self.operator_pattern = re.compile(r'[+\-*/^()[\]{}|=<>≤≥≠≈±∓×÷∘]')
    
    def _should_reject_text(self, text: str) -> bool:
        text_stripped = text.strip()
        
        for pattern in self.rejection_patterns:
            if pattern.search(text_stripped):
                return True
        
        if len(text_stripped) < self.min_math_length:
            return True
        
        if len(text_stripped) > 10:
            alpha_count = sum(1 for c in text_stripped if c.isalpha())
            if alpha_count / len(text_stripped) > 0.8:
                return True
        
        return False
    
    def detect_mathematical_content(self, text: str) -> Tuple[bool, float, Dict]:
        if not text.strip():
            return False, 0.0, {}
        
        if self._should_reject_text(text):
            return False, 0.0, {'rejected': 1}
        
        score = 0.0
        breakdown = {}
        
        # Mathematical symbols (higher weight)
        symbol_matches = len(self.math_symbols_pattern.findall(text))
        if symbol_matches > 0:
            symbol_score = min(4.0, symbol_matches * 0.8)
            score += symbol_score
            breakdown['symbols'] = symbol_matches
        
        # Enhanced equation patterns
        equation_score = 0.0
        for pattern in self.equation_patterns:
            if pattern.search(text):
                equation_score += 2.0
                break
        score += equation_score
        breakdown['equations'] = int(equation_score / 2)
        
        # Operators (require at least 2)
        operator_matches = len(self.operator_pattern.findall(text))
        if operator_matches >= 2:
            operator_score = min(2.0, operator_matches * 0.3)
            score += operator_score
            breakdown['operators'] = operator_matches
        
        # Length penalty for short expressions
        if len(text.strip()) < self.min_math_length:
            score *= 0.5
        
        # Multi-line bonus
        if '\n' in text and len(text.strip()) > 20:
            score += 1.0
            breakdown['multiline_bonus'] = 1
        
        confidence = min(1.0, score / 12.0)
        is_mathematical = score >= self.math_detection_threshold
        
        return is_mathematical, confidence, breakdown


def test_threshold_optimization():
    """Test different thresholds to find optimal balance."""
    
    # Test cases based on actual math files
    false_positives = [
        "In this article we demonstrate that the optimal portfolios generated by the Black-Litterman asset",
        "Black-Litterman model is the scaled market equilibrium portfolio (reﬂecting the uncertainty in the",
        "many ﬁnancial institutions. As developed in the original paper, the Black-Litterman model provides",
        "2  The Black-Litterman Asset Allocation Model",
        "The Black-Litterman asset allocation model uses the Bayesian approach to infer the assets' expected",
        "Page 5",
        "[1]",
        "XXX",
        "x1",
        "R =",
    ]
    
    real_math = [
        "decomposed into the form Ω= V ˆΩV −1 where ˆΩis diagonal. The original views can be transformed into ˆPµ = ˆQ+ˆϵ(v),",
        "E[R] = µ + τ Σ P'(P τ Σ P' + Ω)^(-1) (Q - P µ)",
        "Var[R] = Σ - τ Σ P'(P τ Σ P' + Ω)^(-1) P τ Σ",
        "w* = (γ Σ)^(-1) µ",
        "∑(i=1 to n) w_i = 1",
        "σ² = w'Σw",
        "E(R_p) = w'μ",
        "max{w'μ - (λ/2)w'Σw}",
    ]
    
    # Test different thresholds
    thresholds = [3, 4, 5, 6, 7]
    
    print("Threshold Optimization Analysis")
    print("=" * 60)
    print(f"{'Threshold':<10} {'FP':<4} {'TP':<4} {'Precision':<10} {'Recall':<8} {'F1':<8}")
    print("-" * 60)
    
    best_f1 = 0
    best_threshold = 5
    
    for threshold in thresholds:
        detector = ConfigurableMathDetector(threshold)
        
        fp_count = 0
        tp_count = 0
        
        # Test false positives
        for text in false_positives:
            is_math, _, _ = detector.detect_mathematical_content(text)
            if is_math:
                fp_count += 1
        
        # Test true positives
        for text in real_math:
            is_math, _, _ = detector.detect_mathematical_content(text)
            if is_math:
                tp_count += 1
        
        # Calculate metrics
        precision = tp_count / (tp_count + fp_count) if (tp_count + fp_count) > 0 else 0
        recall = tp_count / len(real_math)
        f1 = 2 * precision * recall / (precision + recall) if (precision + recall) > 0 else 0
        
        if f1 > best_f1:
            best_f1 = f1
            best_threshold = threshold
        
        print(f"{threshold:<10} {fp_count:<4} {tp_count:<4} {precision:<10.2%} {recall:<8.2%} {f1:<8.3f}")
    
    print("-" * 60)
    print(f"Best threshold: {best_threshold} (F1 = {best_f1:.3f})")
    
    # Show detailed results for best threshold
    print(f"\nDetailed Results for Threshold = {best_threshold}")
    print("-" * 60)
    
    detector = ConfigurableMathDetector(best_threshold)
    
    print(f"{'Text (truncated)':<45} {'Detected':<10} {'Type'}")
    print("-" * 60)
    
    for text in false_positives:
        is_math, conf, _ = detector.detect_mathematical_content(text)
        result = f"✓ ({conf:.2f})" if is_math else f"✗ ({conf:.2f})"
        print(f"{text[:43]:<45} {result:<10} {'Regular text'}")
    
    print("-" * 60)
    
    for text in real_math:
        is_math, conf, _ = detector.detect_mathematical_content(text)
        result = f"✓ ({conf:.2f})" if is_math else f"✗ ({conf:.2f})"
        print(f"{text[:43]:<45} {result:<10} {'Real math'}")
    
    return best_threshold


if __name__ == "__main__":
    optimal_threshold = test_threshold_optimization()
    
    print(f"\n" + "=" * 60)
    print("RECOMMENDATION:")
    print(f"Use math_detection_threshold: {optimal_threshold} in your config.yaml")
    print("This provides the best balance between precision and recall")
    print("for your specific mathematical content.")